// @generated by
//     __             _____     _                 ___ ___
//  _ |  |___ ___ ___|   __|___| |_ ___ _____  __| | |_  |
// | |_| |_ -| . |   |__   |  _|   | -_|     ||. |_  |  _|
// |_____|___|___|_|_|_____|___|_|_|___|_|_|_|___| |_|___|
// v0.12.9                         -- www.JsonSchema42.org
//
import assert from "node:assert/strict";
import test from "node:test";
import * as validators from "./validators.js";
import * as mocks from "./mocks.js";
/**
* @description The MIME type of the HTTP message.
* @see {@link http://swagger.io/v2/schema.json#/definitions/mimeType}
*/
test("MimeType", () => {
const mock = mocks.mockMimeType();
const valid = validators.isMimeType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2Scopes}
*/
test("Oauth2Scopes", () => {
const mock = mocks.mockOauth2Scopes();
const valid = validators.isOauth2Scopes(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/collectionFormat}
*/
test("DefinitionsCollectionFormat", () => {
const mock = mocks.mockDefinitionsCollectionFormat();
const valid = validators.isDefinitionsCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/collectionFormatWithMulti}
*/
test("CollectionFormatWithMulti", () => {
const mock = mocks.mockCollectionFormatWithMulti();
const valid = validators.isCollectionFormatWithMulti(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/title}
*/
test("DefinitionsTitle", () => {
const mock = mocks.mockDefinitionsTitle();
const valid = validators.isDefinitionsTitle(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/description}
*/
test("DefinitionsDescription", () => {
const mock = mocks.mockDefinitionsDescription();
const valid = validators.isDefinitionsDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/multipleOf}
*/
test("DefinitionsMultipleOf", () => {
const mock = mocks.mockDefinitionsMultipleOf();
const valid = validators.isDefinitionsMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/maximum}
*/
test("DefinitionsMaximum", () => {
const mock = mocks.mockDefinitionsMaximum();
const valid = validators.isDefinitionsMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/exclusiveMaximum}
*/
test("DefinitionsExclusiveMaximum", () => {
const mock = mocks.mockDefinitionsExclusiveMaximum();
const valid = validators.isDefinitionsExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/minimum}
*/
test("DefinitionsMinimum", () => {
const mock = mocks.mockDefinitionsMinimum();
const valid = validators.isDefinitionsMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/exclusiveMinimum}
*/
test("DefinitionsExclusiveMinimum", () => {
const mock = mocks.mockDefinitionsExclusiveMinimum();
const valid = validators.isDefinitionsExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/maxLength}
*/
test("DefinitionsMaxLength", () => {
const mock = mocks.mockDefinitionsMaxLength();
const valid = validators.isDefinitionsMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/maxItems}
*/
test("DefinitionsMaxItems", () => {
const mock = mocks.mockDefinitionsMaxItems();
const valid = validators.isDefinitionsMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/uniqueItems}
*/
test("DefinitionsUniqueItems", () => {
const mock = mocks.mockDefinitionsUniqueItems();
const valid = validators.isDefinitionsUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @description The Swagger version of this document.
* @see {@link http://swagger.io/v2/schema.json#/properties/swagger}
*/
test("Swagger", () => {
const mock = mocks.mockSwagger();
const valid = validators.isSwagger(mock);
assert.equal(valid, true);
});
/**
* @description A unique and precise title of the API.
* @see {@link http://swagger.io/v2/schema.json#/definitions/info/properties/title}
*/
test("InfoTitle", () => {
const mock = mocks.mockInfoTitle();
const valid = validators.isInfoTitle(mock);
assert.equal(valid, true);
});
/**
* @description A semantic version number of the API.
* @see {@link http://swagger.io/v2/schema.json#/definitions/info/properties/version}
*/
test("Version", () => {
const mock = mocks.mockVersion();
const valid = validators.isVersion(mock);
assert.equal(valid, true);
});
/**
* @description A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/info/properties/description}
*/
test("InfoDescription", () => {
const mock = mocks.mockInfoDescription();
const valid = validators.isInfoDescription(mock);
assert.equal(valid, true);
});
/**
* @description The terms of service for the API.
* @see {@link http://swagger.io/v2/schema.json#/definitions/info/properties/termsOfService}
*/
test("TermsOfService", () => {
const mock = mocks.mockTermsOfService();
const valid = validators.isTermsOfService(mock);
assert.equal(valid, true);
});
/**
* @description The identifying name of the contact person/organization.
* @see {@link http://swagger.io/v2/schema.json#/definitions/contact/properties/name}
*/
test("ContactName", () => {
const mock = mocks.mockContactName();
const valid = validators.isContactName(mock);
assert.equal(valid, true);
});
/**
* @description The name of the license type. It&apos;s encouraged to use an OSI compatible license.
* @see {@link http://swagger.io/v2/schema.json#/definitions/license/properties/name}
*/
test("LicenseName", () => {
const mock = mocks.mockLicenseName();
const valid = validators.isLicenseName(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/externalDocs/properties/description}
*/
test("ExternalDocsDescription", () => {
const mock = mocks.mockExternalDocsDescription();
const valid = validators.isExternalDocsDescription(mock);
assert.equal(valid, true);
});
/**
* @description A brief summary of the operation.
* @see {@link http://swagger.io/v2/schema.json#/definitions/operation/properties/summary}
*/
test("Summary", () => {
const mock = mocks.mockSummary();
const valid = validators.isSummary(mock);
assert.equal(valid, true);
});
/**
* @description A longer description of the operation, GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/operation/properties/description}
*/
test("OperationDescription", () => {
const mock = mocks.mockOperationDescription();
const valid = validators.isOperationDescription(mock);
assert.equal(valid, true);
});
/**
* @description A unique identifier of the operation.
* @see {@link http://swagger.io/v2/schema.json#/definitions/operation/properties/operationId}
*/
test("OperationId", () => {
const mock = mocks.mockOperationId();
const valid = validators.isOperationId(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/operation/properties/deprecated}
*/
test("Deprecated", () => {
const mock = mocks.mockDeprecated();
const valid = validators.isDeprecated(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathItem/properties/$ref}
*/
test("PathItemRef", () => {
const mock = mocks.mockPathItemRef();
const valid = validators.isPathItemRef(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/response/properties/description}
*/
test("ResponseDescription", () => {
const mock = mocks.mockResponseDescription();
const valid = validators.isResponseDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/type}
*/
test("HeaderType", () => {
const mock = mocks.mockHeaderType();
const valid = validators.isHeaderType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/format}
*/
test("HeaderFormat", () => {
const mock = mocks.mockHeaderFormat();
const valid = validators.isHeaderFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/collectionFormat}
*/
test("HeaderCollectionFormat", () => {
const mock = mocks.mockHeaderCollectionFormat();
const valid = validators.isHeaderCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/maximum}
*/
test("HeaderMaximum", () => {
const mock = mocks.mockHeaderMaximum();
const valid = validators.isHeaderMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/exclusiveMaximum}
*/
test("HeaderExclusiveMaximum", () => {
const mock = mocks.mockHeaderExclusiveMaximum();
const valid = validators.isHeaderExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/minimum}
*/
test("HeaderMinimum", () => {
const mock = mocks.mockHeaderMinimum();
const valid = validators.isHeaderMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/exclusiveMinimum}
*/
test("HeaderExclusiveMinimum", () => {
const mock = mocks.mockHeaderExclusiveMinimum();
const valid = validators.isHeaderExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/maxLength}
*/
test("HeaderMaxLength", () => {
const mock = mocks.mockHeaderMaxLength();
const valid = validators.isHeaderMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/maxItems}
*/
test("HeaderMaxItems", () => {
const mock = mocks.mockHeaderMaxItems();
const valid = validators.isHeaderMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/uniqueItems}
*/
test("HeaderUniqueItems", () => {
const mock = mocks.mockHeaderUniqueItems();
const valid = validators.isHeaderUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/multipleOf}
*/
test("HeaderMultipleOf", () => {
const mock = mocks.mockHeaderMultipleOf();
const valid = validators.isHeaderMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/header/properties/description}
*/
test("HeaderDescription", () => {
const mock = mocks.mockHeaderDescription();
const valid = validators.isHeaderDescription(mock);
assert.equal(valid, true);
});
/**
* @description A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/bodyParameter/properties/description}
*/
test("BodyParameterDescription", () => {
const mock = mocks.mockBodyParameterDescription();
const valid = validators.isBodyParameterDescription(mock);
assert.equal(valid, true);
});
/**
* @description The name of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/bodyParameter/properties/name}
*/
test("BodyParameterName", () => {
const mock = mocks.mockBodyParameterName();
const valid = validators.isBodyParameterName(mock);
assert.equal(valid, true);
});
/**
* @description Determines the location of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/bodyParameter/properties/in}
*/
test("BodyParameterIn", () => {
const mock = mocks.mockBodyParameterIn();
const valid = validators.isBodyParameterIn(mock);
assert.equal(valid, true);
});
/**
* @description Determines whether or not this parameter is required or optional.
* @see {@link http://swagger.io/v2/schema.json#/definitions/bodyParameter/properties/required}
*/
test("BodyParameterRequired", () => {
const mock = mocks.mockBodyParameterRequired();
const valid = validators.isBodyParameterRequired(mock);
assert.equal(valid, true);
});
/**
* @description Determines whether or not this parameter is required or optional.
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/required}
*/
test("HeaderParameterSubSchemaRequired", () => {
const mock = mocks.mockHeaderParameterSubSchemaRequired();
const valid = validators.isHeaderParameterSubSchemaRequired(mock);
assert.equal(valid, true);
});
/**
* @description Determines the location of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/in}
*/
test("HeaderParameterSubSchemaIn", () => {
const mock = mocks.mockHeaderParameterSubSchemaIn();
const valid = validators.isHeaderParameterSubSchemaIn(mock);
assert.equal(valid, true);
});
/**
* @description A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/description}
*/
test("HeaderParameterSubSchemaDescription", () => {
const mock = mocks.mockHeaderParameterSubSchemaDescription();
const valid = validators.isHeaderParameterSubSchemaDescription(mock);
assert.equal(valid, true);
});
/**
* @description The name of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/name}
*/
test("HeaderParameterSubSchemaName", () => {
const mock = mocks.mockHeaderParameterSubSchemaName();
const valid = validators.isHeaderParameterSubSchemaName(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/type}
*/
test("HeaderParameterSubSchemaType", () => {
const mock = mocks.mockHeaderParameterSubSchemaType();
const valid = validators.isHeaderParameterSubSchemaType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/format}
*/
test("HeaderParameterSubSchemaFormat", () => {
const mock = mocks.mockHeaderParameterSubSchemaFormat();
const valid = validators.isHeaderParameterSubSchemaFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/collectionFormat}
*/
test("HeaderParameterSubSchemaCollectionFormat", () => {
const mock = mocks.mockHeaderParameterSubSchemaCollectionFormat();
const valid = validators.isHeaderParameterSubSchemaCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/maximum}
*/
test("HeaderParameterSubSchemaMaximum", () => {
const mock = mocks.mockHeaderParameterSubSchemaMaximum();
const valid = validators.isHeaderParameterSubSchemaMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/exclusiveMaximum}
*/
test("HeaderParameterSubSchemaExclusiveMaximum", () => {
const mock = mocks.mockHeaderParameterSubSchemaExclusiveMaximum();
const valid = validators.isHeaderParameterSubSchemaExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/minimum}
*/
test("HeaderParameterSubSchemaMinimum", () => {
const mock = mocks.mockHeaderParameterSubSchemaMinimum();
const valid = validators.isHeaderParameterSubSchemaMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/exclusiveMinimum}
*/
test("HeaderParameterSubSchemaExclusiveMinimum", () => {
const mock = mocks.mockHeaderParameterSubSchemaExclusiveMinimum();
const valid = validators.isHeaderParameterSubSchemaExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/maxLength}
*/
test("HeaderParameterSubSchemaMaxLength", () => {
const mock = mocks.mockHeaderParameterSubSchemaMaxLength();
const valid = validators.isHeaderParameterSubSchemaMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/maxItems}
*/
test("HeaderParameterSubSchemaMaxItems", () => {
const mock = mocks.mockHeaderParameterSubSchemaMaxItems();
const valid = validators.isHeaderParameterSubSchemaMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/uniqueItems}
*/
test("HeaderParameterSubSchemaUniqueItems", () => {
const mock = mocks.mockHeaderParameterSubSchemaUniqueItems();
const valid = validators.isHeaderParameterSubSchemaUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/headerParameterSubSchema/properties/multipleOf}
*/
test("HeaderParameterSubSchemaMultipleOf", () => {
const mock = mocks.mockHeaderParameterSubSchemaMultipleOf();
const valid = validators.isHeaderParameterSubSchemaMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @description Determines whether or not this parameter is required or optional.
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/required}
*/
test("QueryParameterSubSchemaRequired", () => {
const mock = mocks.mockQueryParameterSubSchemaRequired();
const valid = validators.isQueryParameterSubSchemaRequired(mock);
assert.equal(valid, true);
});
/**
* @description Determines the location of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/in}
*/
test("QueryParameterSubSchemaIn", () => {
const mock = mocks.mockQueryParameterSubSchemaIn();
const valid = validators.isQueryParameterSubSchemaIn(mock);
assert.equal(valid, true);
});
/**
* @description A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/description}
*/
test("QueryParameterSubSchemaDescription", () => {
const mock = mocks.mockQueryParameterSubSchemaDescription();
const valid = validators.isQueryParameterSubSchemaDescription(mock);
assert.equal(valid, true);
});
/**
* @description The name of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/name}
*/
test("QueryParameterSubSchemaName", () => {
const mock = mocks.mockQueryParameterSubSchemaName();
const valid = validators.isQueryParameterSubSchemaName(mock);
assert.equal(valid, true);
});
/**
* @description allows sending a parameter by name only or with an empty value.
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/allowEmptyValue}
*/
test("QueryParameterSubSchemaAllowEmptyValue", () => {
const mock = mocks.mockQueryParameterSubSchemaAllowEmptyValue();
const valid = validators.isQueryParameterSubSchemaAllowEmptyValue(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/type}
*/
test("QueryParameterSubSchemaType", () => {
const mock = mocks.mockQueryParameterSubSchemaType();
const valid = validators.isQueryParameterSubSchemaType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/format}
*/
test("QueryParameterSubSchemaFormat", () => {
const mock = mocks.mockQueryParameterSubSchemaFormat();
const valid = validators.isQueryParameterSubSchemaFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/collectionFormat}
*/
test("QueryParameterSubSchemaCollectionFormat", () => {
const mock = mocks.mockQueryParameterSubSchemaCollectionFormat();
const valid = validators.isQueryParameterSubSchemaCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/maximum}
*/
test("QueryParameterSubSchemaMaximum", () => {
const mock = mocks.mockQueryParameterSubSchemaMaximum();
const valid = validators.isQueryParameterSubSchemaMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/exclusiveMaximum}
*/
test("QueryParameterSubSchemaExclusiveMaximum", () => {
const mock = mocks.mockQueryParameterSubSchemaExclusiveMaximum();
const valid = validators.isQueryParameterSubSchemaExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/minimum}
*/
test("QueryParameterSubSchemaMinimum", () => {
const mock = mocks.mockQueryParameterSubSchemaMinimum();
const valid = validators.isQueryParameterSubSchemaMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/exclusiveMinimum}
*/
test("QueryParameterSubSchemaExclusiveMinimum", () => {
const mock = mocks.mockQueryParameterSubSchemaExclusiveMinimum();
const valid = validators.isQueryParameterSubSchemaExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/maxLength}
*/
test("QueryParameterSubSchemaMaxLength", () => {
const mock = mocks.mockQueryParameterSubSchemaMaxLength();
const valid = validators.isQueryParameterSubSchemaMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/maxItems}
*/
test("QueryParameterSubSchemaMaxItems", () => {
const mock = mocks.mockQueryParameterSubSchemaMaxItems();
const valid = validators.isQueryParameterSubSchemaMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/uniqueItems}
*/
test("QueryParameterSubSchemaUniqueItems", () => {
const mock = mocks.mockQueryParameterSubSchemaUniqueItems();
const valid = validators.isQueryParameterSubSchemaUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/queryParameterSubSchema/properties/multipleOf}
*/
test("QueryParameterSubSchemaMultipleOf", () => {
const mock = mocks.mockQueryParameterSubSchemaMultipleOf();
const valid = validators.isQueryParameterSubSchemaMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @description Determines whether or not this parameter is required or optional.
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/required}
*/
test("FormDataParameterSubSchemaRequired", () => {
const mock = mocks.mockFormDataParameterSubSchemaRequired();
const valid = validators.isFormDataParameterSubSchemaRequired(mock);
assert.equal(valid, true);
});
/**
* @description Determines the location of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/in}
*/
test("FormDataParameterSubSchemaIn", () => {
const mock = mocks.mockFormDataParameterSubSchemaIn();
const valid = validators.isFormDataParameterSubSchemaIn(mock);
assert.equal(valid, true);
});
/**
* @description A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/description}
*/
test("FormDataParameterSubSchemaDescription", () => {
const mock = mocks.mockFormDataParameterSubSchemaDescription();
const valid = validators.isFormDataParameterSubSchemaDescription(mock);
assert.equal(valid, true);
});
/**
* @description The name of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/name}
*/
test("FormDataParameterSubSchemaName", () => {
const mock = mocks.mockFormDataParameterSubSchemaName();
const valid = validators.isFormDataParameterSubSchemaName(mock);
assert.equal(valid, true);
});
/**
* @description allows sending a parameter by name only or with an empty value.
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/allowEmptyValue}
*/
test("FormDataParameterSubSchemaAllowEmptyValue", () => {
const mock = mocks.mockFormDataParameterSubSchemaAllowEmptyValue();
const valid = validators.isFormDataParameterSubSchemaAllowEmptyValue(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/type}
*/
test("FormDataParameterSubSchemaType", () => {
const mock = mocks.mockFormDataParameterSubSchemaType();
const valid = validators.isFormDataParameterSubSchemaType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/format}
*/
test("FormDataParameterSubSchemaFormat", () => {
const mock = mocks.mockFormDataParameterSubSchemaFormat();
const valid = validators.isFormDataParameterSubSchemaFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/collectionFormat}
*/
test("FormDataParameterSubSchemaCollectionFormat", () => {
const mock = mocks.mockFormDataParameterSubSchemaCollectionFormat();
const valid = validators.isFormDataParameterSubSchemaCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/maximum}
*/
test("FormDataParameterSubSchemaMaximum", () => {
const mock = mocks.mockFormDataParameterSubSchemaMaximum();
const valid = validators.isFormDataParameterSubSchemaMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/exclusiveMaximum}
*/
test("FormDataParameterSubSchemaExclusiveMaximum", () => {
const mock = mocks.mockFormDataParameterSubSchemaExclusiveMaximum();
const valid = validators.isFormDataParameterSubSchemaExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/minimum}
*/
test("FormDataParameterSubSchemaMinimum", () => {
const mock = mocks.mockFormDataParameterSubSchemaMinimum();
const valid = validators.isFormDataParameterSubSchemaMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/exclusiveMinimum}
*/
test("FormDataParameterSubSchemaExclusiveMinimum", () => {
const mock = mocks.mockFormDataParameterSubSchemaExclusiveMinimum();
const valid = validators.isFormDataParameterSubSchemaExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/maxLength}
*/
test("FormDataParameterSubSchemaMaxLength", () => {
const mock = mocks.mockFormDataParameterSubSchemaMaxLength();
const valid = validators.isFormDataParameterSubSchemaMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/maxItems}
*/
test("FormDataParameterSubSchemaMaxItems", () => {
const mock = mocks.mockFormDataParameterSubSchemaMaxItems();
const valid = validators.isFormDataParameterSubSchemaMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/uniqueItems}
*/
test("FormDataParameterSubSchemaUniqueItems", () => {
const mock = mocks.mockFormDataParameterSubSchemaUniqueItems();
const valid = validators.isFormDataParameterSubSchemaUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/formDataParameterSubSchema/properties/multipleOf}
*/
test("FormDataParameterSubSchemaMultipleOf", () => {
const mock = mocks.mockFormDataParameterSubSchemaMultipleOf();
const valid = validators.isFormDataParameterSubSchemaMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @description Determines whether or not this parameter is required or optional.
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/required}
*/
test("PathParameterSubSchemaRequired", () => {
const mock = mocks.mockPathParameterSubSchemaRequired();
const valid = validators.isPathParameterSubSchemaRequired(mock);
assert.equal(valid, true);
});
/**
* @description Determines the location of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/in}
*/
test("PathParameterSubSchemaIn", () => {
const mock = mocks.mockPathParameterSubSchemaIn();
const valid = validators.isPathParameterSubSchemaIn(mock);
assert.equal(valid, true);
});
/**
* @description A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed.
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/description}
*/
test("PathParameterSubSchemaDescription", () => {
const mock = mocks.mockPathParameterSubSchemaDescription();
const valid = validators.isPathParameterSubSchemaDescription(mock);
assert.equal(valid, true);
});
/**
* @description The name of the parameter.
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/name}
*/
test("PathParameterSubSchemaName", () => {
const mock = mocks.mockPathParameterSubSchemaName();
const valid = validators.isPathParameterSubSchemaName(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/type}
*/
test("PathParameterSubSchemaType", () => {
const mock = mocks.mockPathParameterSubSchemaType();
const valid = validators.isPathParameterSubSchemaType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/format}
*/
test("PathParameterSubSchemaFormat", () => {
const mock = mocks.mockPathParameterSubSchemaFormat();
const valid = validators.isPathParameterSubSchemaFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/collectionFormat}
*/
test("PathParameterSubSchemaCollectionFormat", () => {
const mock = mocks.mockPathParameterSubSchemaCollectionFormat();
const valid = validators.isPathParameterSubSchemaCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/maximum}
*/
test("PathParameterSubSchemaMaximum", () => {
const mock = mocks.mockPathParameterSubSchemaMaximum();
const valid = validators.isPathParameterSubSchemaMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/exclusiveMaximum}
*/
test("PathParameterSubSchemaExclusiveMaximum", () => {
const mock = mocks.mockPathParameterSubSchemaExclusiveMaximum();
const valid = validators.isPathParameterSubSchemaExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/minimum}
*/
test("PathParameterSubSchemaMinimum", () => {
const mock = mocks.mockPathParameterSubSchemaMinimum();
const valid = validators.isPathParameterSubSchemaMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/exclusiveMinimum}
*/
test("PathParameterSubSchemaExclusiveMinimum", () => {
const mock = mocks.mockPathParameterSubSchemaExclusiveMinimum();
const valid = validators.isPathParameterSubSchemaExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/maxLength}
*/
test("PathParameterSubSchemaMaxLength", () => {
const mock = mocks.mockPathParameterSubSchemaMaxLength();
const valid = validators.isPathParameterSubSchemaMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/maxItems}
*/
test("PathParameterSubSchemaMaxItems", () => {
const mock = mocks.mockPathParameterSubSchemaMaxItems();
const valid = validators.isPathParameterSubSchemaMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/uniqueItems}
*/
test("PathParameterSubSchemaUniqueItems", () => {
const mock = mocks.mockPathParameterSubSchemaUniqueItems();
const valid = validators.isPathParameterSubSchemaUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/pathParameterSubSchema/properties/multipleOf}
*/
test("PathParameterSubSchemaMultipleOf", () => {
const mock = mocks.mockPathParameterSubSchemaMultipleOf();
const valid = validators.isPathParameterSubSchemaMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/$ref}
*/
test("SchemaRef", () => {
const mock = mocks.mockSchemaRef();
const valid = validators.isSchemaRef(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/format}
*/
test("SchemaFormat", () => {
const mock = mocks.mockSchemaFormat();
const valid = validators.isSchemaFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/title}
*/
test("SchemaTitle", () => {
const mock = mocks.mockSchemaTitle();
const valid = validators.isSchemaTitle(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/description}
*/
test("SchemaDescription", () => {
const mock = mocks.mockSchemaDescription();
const valid = validators.isSchemaDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/multipleOf}
*/
test("SchemaMultipleOf", () => {
const mock = mocks.mockSchemaMultipleOf();
const valid = validators.isSchemaMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/maximum}
*/
test("SchemaMaximum", () => {
const mock = mocks.mockSchemaMaximum();
const valid = validators.isSchemaMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/exclusiveMaximum}
*/
test("SchemaExclusiveMaximum", () => {
const mock = mocks.mockSchemaExclusiveMaximum();
const valid = validators.isSchemaExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/minimum}
*/
test("SchemaMinimum", () => {
const mock = mocks.mockSchemaMinimum();
const valid = validators.isSchemaMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/exclusiveMinimum}
*/
test("SchemaExclusiveMinimum", () => {
const mock = mocks.mockSchemaExclusiveMinimum();
const valid = validators.isSchemaExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/maxLength}
*/
test("SchemaMaxLength", () => {
const mock = mocks.mockSchemaMaxLength();
const valid = validators.isSchemaMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/maxItems}
*/
test("SchemaMaxItems", () => {
const mock = mocks.mockSchemaMaxItems();
const valid = validators.isSchemaMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/uniqueItems}
*/
test("SchemaUniqueItems", () => {
const mock = mocks.mockSchemaUniqueItems();
const valid = validators.isSchemaUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/maxProperties}
*/
test("MaxProperties", () => {
const mock = mocks.mockMaxProperties();
const valid = validators.isMaxProperties(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/discriminator}
*/
test("Discriminator", () => {
const mock = mocks.mockDiscriminator();
const valid = validators.isDiscriminator(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schema/properties/readOnly}
*/
test("SchemaReadOnly", () => {
const mock = mocks.mockSchemaReadOnly();
const valid = validators.isSchemaReadOnly(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/fileSchema/properties/format}
*/
test("FileSchemaFormat", () => {
const mock = mocks.mockFileSchemaFormat();
const valid = validators.isFileSchemaFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/fileSchema/properties/title}
*/
test("FileSchemaTitle", () => {
const mock = mocks.mockFileSchemaTitle();
const valid = validators.isFileSchemaTitle(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/fileSchema/properties/description}
*/
test("FileSchemaDescription", () => {
const mock = mocks.mockFileSchemaDescription();
const valid = validators.isFileSchemaDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/fileSchema/properties/type}
*/
test("FileSchemaType", () => {
const mock = mocks.mockFileSchemaType();
const valid = validators.isFileSchemaType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/fileSchema/properties/readOnly}
*/
test("FileSchemaReadOnly", () => {
const mock = mocks.mockFileSchemaReadOnly();
const valid = validators.isFileSchemaReadOnly(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/type}
*/
test("PrimitivesItemsType", () => {
const mock = mocks.mockPrimitivesItemsType();
const valid = validators.isPrimitivesItemsType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/format}
*/
test("PrimitivesItemsFormat", () => {
const mock = mocks.mockPrimitivesItemsFormat();
const valid = validators.isPrimitivesItemsFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/collectionFormat}
*/
test("PrimitivesItemsCollectionFormat", () => {
const mock = mocks.mockPrimitivesItemsCollectionFormat();
const valid = validators.isPrimitivesItemsCollectionFormat(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/maximum}
*/
test("PrimitivesItemsMaximum", () => {
const mock = mocks.mockPrimitivesItemsMaximum();
const valid = validators.isPrimitivesItemsMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/exclusiveMaximum}
*/
test("PrimitivesItemsExclusiveMaximum", () => {
const mock = mocks.mockPrimitivesItemsExclusiveMaximum();
const valid = validators.isPrimitivesItemsExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/minimum}
*/
test("PrimitivesItemsMinimum", () => {
const mock = mocks.mockPrimitivesItemsMinimum();
const valid = validators.isPrimitivesItemsMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/exclusiveMinimum}
*/
test("PrimitivesItemsExclusiveMinimum", () => {
const mock = mocks.mockPrimitivesItemsExclusiveMinimum();
const valid = validators.isPrimitivesItemsExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/maxLength}
*/
test("PrimitivesItemsMaxLength", () => {
const mock = mocks.mockPrimitivesItemsMaxLength();
const valid = validators.isPrimitivesItemsMaxLength(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/maxItems}
*/
test("PrimitivesItemsMaxItems", () => {
const mock = mocks.mockPrimitivesItemsMaxItems();
const valid = validators.isPrimitivesItemsMaxItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/uniqueItems}
*/
test("PrimitivesItemsUniqueItems", () => {
const mock = mocks.mockPrimitivesItemsUniqueItems();
const valid = validators.isPrimitivesItemsUniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/primitivesItems/properties/multipleOf}
*/
test("PrimitivesItemsMultipleOf", () => {
const mock = mocks.mockPrimitivesItemsMultipleOf();
const valid = validators.isPrimitivesItemsMultipleOf(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/xml/properties/name}
*/
test("XmlName", () => {
const mock = mocks.mockXmlName();
const valid = validators.isXmlName(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/xml/properties/namespace}
*/
test("Namespace", () => {
const mock = mocks.mockNamespace();
const valid = validators.isNamespace(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/xml/properties/prefix}
*/
test("Prefix", () => {
const mock = mocks.mockPrefix();
const valid = validators.isPrefix(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/xml/properties/attribute}
*/
test("Attribute", () => {
const mock = mocks.mockAttribute();
const valid = validators.isAttribute(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/xml/properties/wrapped}
*/
test("Wrapped", () => {
const mock = mocks.mockWrapped();
const valid = validators.isWrapped(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/tag/properties/name}
*/
test("TagName", () => {
const mock = mocks.mockTagName();
const valid = validators.isTagName(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/tag/properties/description}
*/
test("TagDescription", () => {
const mock = mocks.mockTagDescription();
const valid = validators.isTagDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/basicAuthenticationSecurity/properties/type}
*/
test("BasicAuthenticationSecurityType", () => {
const mock = mocks.mockBasicAuthenticationSecurityType();
const valid = validators.isBasicAuthenticationSecurityType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/basicAuthenticationSecurity/properties/description}
*/
test("BasicAuthenticationSecurityDescription", () => {
const mock = mocks.mockBasicAuthenticationSecurityDescription();
const valid = validators.isBasicAuthenticationSecurityDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/apiKeySecurity/properties/type}
*/
test("ApiKeySecurityType", () => {
const mock = mocks.mockApiKeySecurityType();
const valid = validators.isApiKeySecurityType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/apiKeySecurity/properties/name}
*/
test("ApiKeySecurityName", () => {
const mock = mocks.mockApiKeySecurityName();
const valid = validators.isApiKeySecurityName(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/apiKeySecurity/properties/in}
*/
test("ApiKeySecurityIn", () => {
const mock = mocks.mockApiKeySecurityIn();
const valid = validators.isApiKeySecurityIn(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/apiKeySecurity/properties/description}
*/
test("ApiKeySecurityDescription", () => {
const mock = mocks.mockApiKeySecurityDescription();
const valid = validators.isApiKeySecurityDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ImplicitSecurity/properties/type}
*/
test("Oauth2ImplicitSecurityType", () => {
const mock = mocks.mockOauth2ImplicitSecurityType();
const valid = validators.isOauth2ImplicitSecurityType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ImplicitSecurity/properties/flow}
*/
test("Oauth2ImplicitSecurityFlow", () => {
const mock = mocks.mockOauth2ImplicitSecurityFlow();
const valid = validators.isOauth2ImplicitSecurityFlow(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ImplicitSecurity/properties/scopes}
*/
test("Oauth2ImplicitSecurityScopes", () => {
const mock = mocks.mockOauth2ImplicitSecurityScopes();
const valid = validators.isOauth2ImplicitSecurityScopes(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ImplicitSecurity/properties/description}
*/
test("Oauth2ImplicitSecurityDescription", () => {
const mock = mocks.mockOauth2ImplicitSecurityDescription();
const valid = validators.isOauth2ImplicitSecurityDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2PasswordSecurity/properties/type}
*/
test("Oauth2PasswordSecurityType", () => {
const mock = mocks.mockOauth2PasswordSecurityType();
const valid = validators.isOauth2PasswordSecurityType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2PasswordSecurity/properties/flow}
*/
test("Oauth2PasswordSecurityFlow", () => {
const mock = mocks.mockOauth2PasswordSecurityFlow();
const valid = validators.isOauth2PasswordSecurityFlow(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2PasswordSecurity/properties/scopes}
*/
test("Oauth2PasswordSecurityScopes", () => {
const mock = mocks.mockOauth2PasswordSecurityScopes();
const valid = validators.isOauth2PasswordSecurityScopes(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2PasswordSecurity/properties/description}
*/
test("Oauth2PasswordSecurityDescription", () => {
const mock = mocks.mockOauth2PasswordSecurityDescription();
const valid = validators.isOauth2PasswordSecurityDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ApplicationSecurity/properties/type}
*/
test("Oauth2ApplicationSecurityType", () => {
const mock = mocks.mockOauth2ApplicationSecurityType();
const valid = validators.isOauth2ApplicationSecurityType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ApplicationSecurity/properties/flow}
*/
test("Oauth2ApplicationSecurityFlow", () => {
const mock = mocks.mockOauth2ApplicationSecurityFlow();
const valid = validators.isOauth2ApplicationSecurityFlow(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ApplicationSecurity/properties/scopes}
*/
test("Oauth2ApplicationSecurityScopes", () => {
const mock = mocks.mockOauth2ApplicationSecurityScopes();
const valid = validators.isOauth2ApplicationSecurityScopes(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2ApplicationSecurity/properties/description}
*/
test("Oauth2ApplicationSecurityDescription", () => {
const mock = mocks.mockOauth2ApplicationSecurityDescription();
const valid = validators.isOauth2ApplicationSecurityDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2AccessCodeSecurity/properties/type}
*/
test("Oauth2AccessCodeSecurityType", () => {
const mock = mocks.mockOauth2AccessCodeSecurityType();
const valid = validators.isOauth2AccessCodeSecurityType(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2AccessCodeSecurity/properties/flow}
*/
test("Oauth2AccessCodeSecurityFlow", () => {
const mock = mocks.mockOauth2AccessCodeSecurityFlow();
const valid = validators.isOauth2AccessCodeSecurityFlow(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2AccessCodeSecurity/properties/scopes}
*/
test("Oauth2AccessCodeSecurityScopes", () => {
const mock = mocks.mockOauth2AccessCodeSecurityScopes();
const valid = validators.isOauth2AccessCodeSecurityScopes(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2AccessCodeSecurity/properties/description}
*/
test("Oauth2AccessCodeSecurityDescription", () => {
const mock = mocks.mockOauth2AccessCodeSecurityDescription();
const valid = validators.isOauth2AccessCodeSecurityDescription(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/oauth2Scopes/additionalProperties}
*/
test("Oauth2ScopesAdditionalProperties", () => {
const mock = mocks.mockOauth2ScopesAdditionalProperties();
const valid = validators.isOauth2ScopesAdditionalProperties(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/mediaTypeList/items}
*/
test("MediaTypeListItems", () => {
const mock = mocks.mockMediaTypeListItems();
const valid = validators.isMediaTypeListItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/schemesList/items}
*/
test("SchemesListItems", () => {
const mock = mocks.mockSchemesListItems();
const valid = validators.isSchemesListItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/jsonReference/properties/$ref}
*/
test("JsonReferenceRef", () => {
const mock = mocks.mockJsonReferenceRef();
const valid = validators.isJsonReferenceRef(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/operation/properties/tags/items}
*/
test("OperationTagsItems", () => {
const mock = mocks.mockOperationTagsItems();
const valid = validators.isOperationTagsItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://swagger.io/v2/schema.json#/definitions/securityRequirement/additionalProperties/items}
*/
test("SecurityRequirementItems", () => {
const mock = mocks.mockSecurityRequirementItems();
const valid = validators.isSecurityRequirementItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/title}
*/
test("Draft04Title", () => {
const mock = mocks.mockDraft04Title();
const valid = validators.isDraft04Title(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/description}
*/
test("Draft04Description", () => {
const mock = mocks.mockDraft04Description();
const valid = validators.isDraft04Description(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/multipleOf}
*/
test("Draft04MultipleOf", () => {
const mock = mocks.mockDraft04MultipleOf();
const valid = validators.isDraft04MultipleOf(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/maximum}
*/
test("Draft04Maximum", () => {
const mock = mocks.mockDraft04Maximum();
const valid = validators.isDraft04Maximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum}
*/
test("Draft04ExclusiveMaximum", () => {
const mock = mocks.mockDraft04ExclusiveMaximum();
const valid = validators.isDraft04ExclusiveMaximum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/minimum}
*/
test("Draft04Minimum", () => {
const mock = mocks.mockDraft04Minimum();
const valid = validators.isDraft04Minimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum}
*/
test("Draft04ExclusiveMinimum", () => {
const mock = mocks.mockDraft04ExclusiveMinimum();
const valid = validators.isDraft04ExclusiveMinimum(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/definitions/positiveInteger}
*/
test("PositiveInteger", () => {
const mock = mocks.mockPositiveInteger();
const valid = validators.isPositiveInteger(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0/allOf/0}
*/
test("PositiveIntegerDefault00", () => {
const mock = mocks.mockPositiveIntegerDefault00();
const valid = validators.isPositiveIntegerDefault00(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/properties/uniqueItems}
*/
test("Draft04UniqueItems", () => {
const mock = mocks.mockDraft04UniqueItems();
const valid = validators.isDraft04UniqueItems(mock);
assert.equal(valid, true);
});
/**
* @see {@link http://json-schema.org/draft-04/schema#/definitions/stringArray/items}
*/
test("StringArrayItems", () => {
const mock = mocks.mockStringArrayItems();
const valid = validators.isStringArrayItems(mock);
assert.equal(valid, true);
});
